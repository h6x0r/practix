import { Task } from '../../../../../../../types';

export const task: Task = {
	slug: 'interview-vuln-assessment',
	title: 'Vulnerability Assessment Demo',
	difficulty: 'medium',
	tags: ['security', 'interview', 'vulnerability', 'assessment', 'typescript'],
	estimatedTime: '30m',
	isPremium: true,
	youtubeUrl: '',
	description: `Practice vulnerability assessment skills for technical security interviews.

**Assessment Areas:**

1. **Vulnerability Scanning** - Tools and techniques
2. **CVSS Scoring** - Understanding severity ratings
3. **Risk Prioritization** - Which vulnerabilities matter most
4. **Remediation Planning** - How to fix vulnerabilities
5. **Reporting** - Communicating findings effectively

**Your Task:**

Implement a \`VulnerabilityAssessor\` class that demonstrates vulnerability assessment methodology.`,
	initialCode: `interface Vulnerability {
  id: string;
  cve?: string;
  title: string;
  description: string;
  affectedAsset: string;
  discoveredDate: Date;
  cvssVector?: string;
  cvssScore?: number;
  exploitAvailable: boolean;
  patchAvailable: boolean;
}

interface CVSSBreakdown {
  attackVector: 'network' | 'adjacent' | 'local' | 'physical';
  attackComplexity: 'low' | 'high';
  privilegesRequired: 'none' | 'low' | 'high';
  userInteraction: 'none' | 'required';
  scope: 'unchanged' | 'changed';
  confidentialityImpact: 'none' | 'low' | 'high';
  integrityImpact: 'none' | 'low' | 'high';
  availabilityImpact: 'none' | 'low' | 'high';
}

interface AssessmentReport {
  assetId: string;
  scanDate: Date;
  vulnerabilities: Vulnerability[];
  riskSummary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  topPriorities: Vulnerability[];
  recommendations: string[];
}

interface RemediationPlan {
  vulnerabilityId: string;
  priority: 'immediate' | 'high' | 'medium' | 'low';
  actions: string[];
  estimatedEffort: string;
  dependencies: string[];
  verificationSteps: string[];
}

class VulnerabilityAssessor {
  private vulnerabilities: Map<string, Vulnerability> = new Map();

  // Vulnerability Management
  addVulnerability(vuln: Vulnerability): void {
    // TODO: Add a vulnerability
  }

  getVulnerabilitiesByAsset(assetId: string): Vulnerability[] {
    // TODO: Get vulnerabilities for an asset
    return [];
  }

  // CVSS Calculation
  calculateCVSS(breakdown: CVSSBreakdown): number {
    // TODO: Calculate CVSS 3.1 base score
    return 0;
  }

  classifySeverity(cvssScore: number): 'critical' | 'high' | 'medium' | 'low' | 'none' {
    // TODO: Classify severity based on CVSS score
    return 'none';
  }

  // Risk Prioritization
  prioritizeVulnerabilities(): Vulnerability[] {
    // TODO: Sort vulnerabilities by risk (CVSS, exploit availability, patch)
    return [];
  }

  calculateRiskScore(vuln: Vulnerability): number {
    // TODO: Calculate risk score considering multiple factors
    return 0;
  }

  // Remediation
  createRemediationPlan(vulnerabilityId: string): RemediationPlan {
    // TODO: Create a remediation plan for a vulnerability
    return {} as RemediationPlan;
  }

  groupRemediationEfforts(): {
    group: string;
    vulnerabilities: string[];
    sharedAction: string;
  }[] {
    // TODO: Group vulnerabilities that can be fixed together
    return [];
  }

  // Reporting
  generateAssessmentReport(assetId: string): AssessmentReport {
    // TODO: Generate a comprehensive assessment report
    return {} as AssessmentReport;
  }

  compareScans(previousScan: AssessmentReport, currentScan: AssessmentReport): {
    newVulnerabilities: Vulnerability[];
    resolvedVulnerabilities: Vulnerability[];
    unchangedVulnerabilities: Vulnerability[];
    trendAnalysis: string;
  } {
    // TODO: Compare two scans to show progress
    return {} as any;
  }

  // Interview Helpers
  explainCVSSVector(vector: string): string {
    // TODO: Explain a CVSS vector string in plain language
    return '';
  }

  suggestInterviewResponse(scenario: string): string {
    // TODO: Suggest how to respond to a vulnerability assessment scenario
    return '';
  }
}

// Test your implementation
const assessor = new VulnerabilityAssessor();

// Test 1: Add vulnerability
assessor.addVulnerability({
  id: 'v1',
  cve: 'CVE-2021-44228',
  title: 'Log4Shell',
  description: 'Remote code execution in Log4j',
  affectedAsset: 'server-001',
  discoveredDate: new Date(),
  cvssScore: 10.0,
  exploitAvailable: true,
  patchAvailable: true,
});
console.log('Test 1 - Vuln added:', assessor.getVulnerabilitiesByAsset('server-001').length === 1);

// Test 2: Calculate CVSS
const cvss = assessor.calculateCVSS({
  attackVector: 'network',
  attackComplexity: 'low',
  privilegesRequired: 'none',
  userInteraction: 'none',
  scope: 'changed',
  confidentialityImpact: 'high',
  integrityImpact: 'high',
  availabilityImpact: 'high',
});
console.log('Test 2 - CVSS calculated:', cvss >= 9.0);

// Test 3: Classify severity
console.log('Test 3 - Severity classified:', assessor.classifySeverity(9.5) === 'critical');

// Test 4: Add more vulns and prioritize
assessor.addVulnerability({
  id: 'v2',
  title: 'XSS Vulnerability',
  description: 'Reflected XSS in search',
  affectedAsset: 'server-001',
  discoveredDate: new Date(),
  cvssScore: 6.1,
  exploitAvailable: true,
  patchAvailable: false,
});
const prioritized = assessor.prioritizeVulnerabilities();
console.log('Test 4 - Prioritized:', prioritized[0]?.id === 'v1');

// Test 5: Calculate risk score
const riskScore = assessor.calculateRiskScore(assessor.getVulnerabilitiesByAsset('server-001')[0]);
console.log('Test 5 - Risk score:', riskScore > 0);

// Test 6: Create remediation plan
const plan = assessor.createRemediationPlan('v1');
console.log('Test 6 - Remediation plan:', plan.priority === 'immediate');

// Test 7: Group remediation
const groups = assessor.groupRemediationEfforts();
console.log('Test 7 - Grouped:', Array.isArray(groups));

// Test 8: Generate report
const report = assessor.generateAssessmentReport('server-001');
console.log('Test 8 - Report generated:', report.vulnerabilities.length > 0);

// Test 9: Explain CVSS vector
const explanation = assessor.explainCVSSVector('AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H');
console.log('Test 9 - Vector explained:', explanation.length > 0);

// Test 10: Interview response
const response = assessor.suggestInterviewResponse('critical vulnerability found');
console.log('Test 10 - Interview response:', response.length > 0);`,
	solutionCode: `interface Vulnerability {
  id: string;
  cve?: string;
  title: string;
  description: string;
  affectedAsset: string;
  discoveredDate: Date;
  cvssVector?: string;
  cvssScore?: number;
  exploitAvailable: boolean;
  patchAvailable: boolean;
}

interface CVSSBreakdown {
  attackVector: 'network' | 'adjacent' | 'local' | 'physical';
  attackComplexity: 'low' | 'high';
  privilegesRequired: 'none' | 'low' | 'high';
  userInteraction: 'none' | 'required';
  scope: 'unchanged' | 'changed';
  confidentialityImpact: 'none' | 'low' | 'high';
  integrityImpact: 'none' | 'low' | 'high';
  availabilityImpact: 'none' | 'low' | 'high';
}

interface AssessmentReport {
  assetId: string;
  scanDate: Date;
  vulnerabilities: Vulnerability[];
  riskSummary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  topPriorities: Vulnerability[];
  recommendations: string[];
}

interface RemediationPlan {
  vulnerabilityId: string;
  priority: 'immediate' | 'high' | 'medium' | 'low';
  actions: string[];
  estimatedEffort: string;
  dependencies: string[];
  verificationSteps: string[];
}

class VulnerabilityAssessor {
  private vulnerabilities: Map<string, Vulnerability> = new Map();

  addVulnerability(vuln: Vulnerability): void {
    this.vulnerabilities.set(vuln.id, vuln);
  }

  getVulnerabilitiesByAsset(assetId: string): Vulnerability[] {
    return Array.from(this.vulnerabilities.values()).filter(v => v.affectedAsset === assetId);
  }

  calculateCVSS(breakdown: CVSSBreakdown): number {
    // CVSS 3.1 Base Score calculation (simplified but accurate)
    const avValues = { network: 0.85, adjacent: 0.62, local: 0.55, physical: 0.2 };
    const acValues = { low: 0.77, high: 0.44 };
    const prValuesUnchanged = { none: 0.85, low: 0.62, high: 0.27 };
    const prValuesChanged = { none: 0.85, low: 0.68, high: 0.5 };
    const uiValues = { none: 0.85, required: 0.62 };
    const impactValues = { none: 0, low: 0.22, high: 0.56 };

    const av = avValues[breakdown.attackVector];
    const ac = acValues[breakdown.attackComplexity];
    const pr = breakdown.scope === 'changed'
      ? prValuesChanged[breakdown.privilegesRequired]
      : prValuesUnchanged[breakdown.privilegesRequired];
    const ui = uiValues[breakdown.userInteraction];

    const c = impactValues[breakdown.confidentialityImpact];
    const i = impactValues[breakdown.integrityImpact];
    const a = impactValues[breakdown.availabilityImpact];

    // Exploitability
    const exploitability = 8.22 * av * ac * pr * ui;

    // Impact
    const iscBase = 1 - (1 - c) * (1 - i) * (1 - a);
    let impact: number;

    if (breakdown.scope === 'unchanged') {
      impact = 6.42 * iscBase;
    } else {
      impact = 7.52 * (iscBase - 0.029) - 3.25 * Math.pow(iscBase - 0.02, 15);
    }

    if (impact <= 0) return 0;

    let score: number;
    if (breakdown.scope === 'unchanged') {
      score = Math.min(impact + exploitability, 10);
    } else {
      score = Math.min(1.08 * (impact + exploitability), 10);
    }

    // Round up to one decimal
    return Math.ceil(score * 10) / 10;
  }

  classifySeverity(cvssScore: number): 'critical' | 'high' | 'medium' | 'low' | 'none' {
    if (cvssScore >= 9.0) return 'critical';
    if (cvssScore >= 7.0) return 'high';
    if (cvssScore >= 4.0) return 'medium';
    if (cvssScore >= 0.1) return 'low';
    return 'none';
  }

  prioritizeVulnerabilities(): Vulnerability[] {
    return Array.from(this.vulnerabilities.values()).sort((a, b) => {
      const scoreA = this.calculateRiskScore(a);
      const scoreB = this.calculateRiskScore(b);
      return scoreB - scoreA;
    });
  }

  calculateRiskScore(vuln: Vulnerability): number {
    let score = vuln.cvssScore || 0;

    // Increase risk if exploit is available
    if (vuln.exploitAvailable) {
      score *= 1.3;
    }

    // Decrease risk if patch is available (easier to fix)
    if (vuln.patchAvailable) {
      score *= 1.1; // Still prioritize because it's fixable
    } else {
      score *= 1.2; // Higher risk because harder to fix
    }

    // Consider age - older vulnerabilities may have more exploits
    const ageInDays = (Date.now() - vuln.discoveredDate.getTime()) / (1000 * 60 * 60 * 24);
    if (ageInDays > 90) {
      score *= 1.1; // Old unpatched vuln is higher risk
    }

    return Math.min(score, 15); // Cap at 15 for scoring purposes
  }

  createRemediationPlan(vulnerabilityId: string): RemediationPlan {
    const vuln = this.vulnerabilities.get(vulnerabilityId);
    if (!vuln) {
      return {
        vulnerabilityId,
        priority: 'low',
        actions: ['Investigate vulnerability'],
        estimatedEffort: 'Unknown',
        dependencies: [],
        verificationSteps: ['Verify fix'],
      };
    }

    const severity = this.classifySeverity(vuln.cvssScore || 0);
    let priority: RemediationPlan['priority'];
    let estimatedEffort: string;
    const actions: string[] = [];
    const dependencies: string[] = [];
    const verificationSteps: string[] = [];

    // Determine priority
    if (severity === 'critical' || (vuln.exploitAvailable && severity === 'high')) {
      priority = 'immediate';
      estimatedEffort = '1-4 hours';
    } else if (severity === 'high') {
      priority = 'high';
      estimatedEffort = '1-2 days';
    } else if (severity === 'medium') {
      priority = 'medium';
      estimatedEffort = '1 week';
    } else {
      priority = 'low';
      estimatedEffort = 'Next maintenance window';
    }

    // Determine actions
    if (vuln.patchAvailable) {
      actions.push(\`Apply patch for \${vuln.cve || vuln.title}\`);
      actions.push('Test patch in staging environment');
      actions.push('Schedule maintenance window for production');
    } else {
      actions.push('Implement compensating controls');
      actions.push('Consider network segmentation');
      actions.push('Increase monitoring for affected asset');
    }

    if (vuln.exploitAvailable) {
      actions.unshift('Implement immediate mitigation (WAF rules, IP blocking)');
      verificationSteps.push('Verify exploit no longer works');
    }

    // Common verification steps
    verificationSteps.push('Run vulnerability scan to confirm fix');
    verificationSteps.push('Review logs for any exploitation attempts');
    verificationSteps.push('Document remediation in tracking system');

    // Dependencies
    if (vuln.patchAvailable) {
      dependencies.push('Change management approval');
      dependencies.push('Backup of affected system');
    }

    return {
      vulnerabilityId,
      priority,
      actions,
      estimatedEffort,
      dependencies,
      verificationSteps,
    };
  }

  groupRemediationEfforts(): {
    group: string;
    vulnerabilities: string[];
    sharedAction: string;
  }[] {
    const groups: Map<string, string[]> = new Map();

    for (const vuln of this.vulnerabilities.values()) {
      // Group by asset
      const assetKey = \`asset:\${vuln.affectedAsset}\`;
      if (!groups.has(assetKey)) {
        groups.set(assetKey, []);
      }
      groups.get(assetKey)!.push(vuln.id);

      // Group by CVE prefix (same software)
      if (vuln.cve) {
        const cveYear = vuln.cve.split('-')[1];
        const softwareKey = \`software:\${cveYear}\`;
        if (!groups.has(softwareKey)) {
          groups.set(softwareKey, []);
        }
        groups.get(softwareKey)!.push(vuln.id);
      }
    }

    return Array.from(groups.entries())
      .filter(([_, vulns]) => vulns.length > 1)
      .map(([group, vulns]) => ({
        group,
        vulnerabilities: [...new Set(vulns)],
        sharedAction: group.startsWith('asset:')
          ? 'Coordinate patching on same system'
          : 'Apply software update covering multiple CVEs',
      }));
  }

  generateAssessmentReport(assetId: string): AssessmentReport {
    const assetVulns = this.getVulnerabilitiesByAsset(assetId);

    const riskSummary = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
    };

    for (const vuln of assetVulns) {
      const severity = this.classifySeverity(vuln.cvssScore || 0);
      if (severity !== 'none') {
        riskSummary[severity]++;
      }
    }

    const recommendations: string[] = [];

    if (riskSummary.critical > 0) {
      recommendations.push('URGENT: Address critical vulnerabilities immediately');
    }
    if (riskSummary.high > 0) {
      recommendations.push('Schedule high-priority patching within 7 days');
    }
    if (assetVulns.some(v => v.exploitAvailable)) {
      recommendations.push('Implement WAF rules for exploitable vulnerabilities');
    }
    if (assetVulns.some(v => !v.patchAvailable)) {
      recommendations.push('Develop compensating controls for unpatched vulnerabilities');
    }

    recommendations.push('Enable continuous vulnerability scanning');
    recommendations.push('Review and update security baseline');

    return {
      assetId,
      scanDate: new Date(),
      vulnerabilities: assetVulns,
      riskSummary,
      topPriorities: this.prioritizeVulnerabilities().filter(v => v.affectedAsset === assetId).slice(0, 5),
      recommendations,
    };
  }

  compareScans(previousScan: AssessmentReport, currentScan: AssessmentReport): {
    newVulnerabilities: Vulnerability[];
    resolvedVulnerabilities: Vulnerability[];
    unchangedVulnerabilities: Vulnerability[];
    trendAnalysis: string;
  } {
    const prevIds = new Set(previousScan.vulnerabilities.map(v => v.id));
    const currIds = new Set(currentScan.vulnerabilities.map(v => v.id));

    const newVulnerabilities = currentScan.vulnerabilities.filter(v => !prevIds.has(v.id));
    const resolvedVulnerabilities = previousScan.vulnerabilities.filter(v => !currIds.has(v.id));
    const unchangedVulnerabilities = currentScan.vulnerabilities.filter(v => prevIds.has(v.id));

    let trendAnalysis: string;
    const prevTotal = previousScan.vulnerabilities.length;
    const currTotal = currentScan.vulnerabilities.length;

    if (currTotal < prevTotal) {
      const reduction = Math.round(((prevTotal - currTotal) / prevTotal) * 100);
      trendAnalysis = \`Positive trend: \${reduction}% reduction in vulnerabilities (\${resolvedVulnerabilities.length} resolved)\`;
    } else if (currTotal > prevTotal) {
      const increase = Math.round(((currTotal - prevTotal) / prevTotal) * 100);
      trendAnalysis = \`Negative trend: \${increase}% increase in vulnerabilities (\${newVulnerabilities.length} new)\`;
    } else {
      trendAnalysis = \`Stable: Same number of vulnerabilities, but \${newVulnerabilities.length} new and \${resolvedVulnerabilities.length} resolved\`;
    }

    return {
      newVulnerabilities,
      resolvedVulnerabilities,
      unchangedVulnerabilities,
      trendAnalysis,
    };
  }

  explainCVSSVector(vector: string): string {
    const parts = vector.split('/');
    const explanations: string[] = [];

    const mappings: Record<string, Record<string, string>> = {
      AV: { N: 'Network attack vector (remotely exploitable)', A: 'Adjacent network required', L: 'Local access required', P: 'Physical access required' },
      AC: { L: 'Low attack complexity (easy to exploit)', H: 'High attack complexity' },
      PR: { N: 'No privileges required', L: 'Low privileges required', H: 'High privileges required' },
      UI: { N: 'No user interaction needed', R: 'User interaction required' },
      S: { U: 'Scope unchanged (affects only vulnerable component)', C: 'Scope changed (can affect other components)' },
      C: { N: 'No confidentiality impact', L: 'Low confidentiality impact', H: 'High confidentiality impact (data breach possible)' },
      I: { N: 'No integrity impact', L: 'Low integrity impact', H: 'High integrity impact (data modification possible)' },
      A: { N: 'No availability impact', L: 'Low availability impact', H: 'High availability impact (service disruption possible)' },
    };

    for (const part of parts) {
      const [key, value] = part.split(':');
      if (mappings[key] && mappings[key][value]) {
        explanations.push(mappings[key][value]);
      }
    }

    return explanations.join('. ');
  }

  suggestInterviewResponse(scenario: string): string {
    const responses: Record<string, string> = {
      'critical vulnerability found': 'First, I would assess the scope and confirm the vulnerability exists. Then immediately implement any available mitigations while planning for a permanent fix. I would notify stakeholders and document everything for incident tracking.',
      'no patch available': 'When no patch is available, I would implement compensating controls such as network segmentation, WAF rules, or enhanced monitoring. I would also evaluate the business impact and consider taking the affected system offline if the risk is too high.',
      'many vulnerabilities': 'I would prioritize based on CVSS score, exploit availability, and business impact. Focus on critical and high severity first, especially those with known exploits. Group vulnerabilities by system or software to optimize patching efforts.',
      'executive asks about risk': 'I would explain in business terms: the potential impact (data breach, service outage, regulatory fines), the likelihood based on exploit availability, and what resources are needed to address it. Provide clear options with trade-offs.',
      'default': 'I would follow a structured approach: assess the scope, prioritize based on risk, implement mitigations, plan remediation, verify fixes, and document lessons learned.',
    };

    const scenarioLower = scenario.toLowerCase();

    for (const [key, response] of Object.entries(responses)) {
      if (scenarioLower.includes(key)) {
        return response;
      }
    }

    return responses['default'];
  }
}

// Test your implementation
const assessor = new VulnerabilityAssessor();

// Test 1: Add vulnerability
assessor.addVulnerability({
  id: 'v1',
  cve: 'CVE-2021-44228',
  title: 'Log4Shell',
  description: 'Remote code execution in Log4j',
  affectedAsset: 'server-001',
  discoveredDate: new Date(),
  cvssScore: 10.0,
  exploitAvailable: true,
  patchAvailable: true,
});
console.log('Test 1 - Vuln added:', assessor.getVulnerabilitiesByAsset('server-001').length === 1);

// Test 2: Calculate CVSS
const cvss = assessor.calculateCVSS({
  attackVector: 'network',
  attackComplexity: 'low',
  privilegesRequired: 'none',
  userInteraction: 'none',
  scope: 'changed',
  confidentialityImpact: 'high',
  integrityImpact: 'high',
  availabilityImpact: 'high',
});
console.log('Test 2 - CVSS calculated:', cvss >= 9.0);

// Test 3: Classify severity
console.log('Test 3 - Severity classified:', assessor.classifySeverity(9.5) === 'critical');

// Test 4: Add more vulns and prioritize
assessor.addVulnerability({
  id: 'v2',
  title: 'XSS Vulnerability',
  description: 'Reflected XSS in search',
  affectedAsset: 'server-001',
  discoveredDate: new Date(),
  cvssScore: 6.1,
  exploitAvailable: true,
  patchAvailable: false,
});
const prioritized = assessor.prioritizeVulnerabilities();
console.log('Test 4 - Prioritized:', prioritized[0]?.id === 'v1');

// Test 5: Calculate risk score
const riskScore = assessor.calculateRiskScore(assessor.getVulnerabilitiesByAsset('server-001')[0]);
console.log('Test 5 - Risk score:', riskScore > 0);

// Test 6: Create remediation plan
const plan = assessor.createRemediationPlan('v1');
console.log('Test 6 - Remediation plan:', plan.priority === 'immediate');

// Test 7: Group remediation
const groups = assessor.groupRemediationEfforts();
console.log('Test 7 - Grouped:', Array.isArray(groups));

// Test 8: Generate report
const report = assessor.generateAssessmentReport('server-001');
console.log('Test 8 - Report generated:', report.vulnerabilities.length > 0);

// Test 9: Explain CVSS vector
const explanation = assessor.explainCVSSVector('AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H');
console.log('Test 9 - Vector explained:', explanation.length > 0);

// Test 10: Interview response
const response = assessor.suggestInterviewResponse('critical vulnerability found');
console.log('Test 10 - Interview response:', response.length > 0);`,
	testCode: `import { describe, it, expect, beforeEach } from 'vitest';

interface Vulnerability {
  id: string;
  cve?: string;
  title: string;
  description: string;
  affectedAsset: string;
  discoveredDate: Date;
  cvssVector?: string;
  cvssScore?: number;
  exploitAvailable: boolean;
  patchAvailable: boolean;
}

interface CVSSBreakdown {
  attackVector: 'network' | 'adjacent' | 'local' | 'physical';
  attackComplexity: 'low' | 'high';
  privilegesRequired: 'none' | 'low' | 'high';
  userInteraction: 'none' | 'required';
  scope: 'unchanged' | 'changed';
  confidentialityImpact: 'none' | 'low' | 'high';
  integrityImpact: 'none' | 'low' | 'high';
  availabilityImpact: 'none' | 'low' | 'high';
}

interface RemediationPlan {
  vulnerabilityId: string;
  priority: 'immediate' | 'high' | 'medium' | 'low';
  actions: string[];
  estimatedEffort: string;
  dependencies: string[];
  verificationSteps: string[];
}

interface AssessmentReport {
  assetId: string;
  scanDate: Date;
  vulnerabilities: Vulnerability[];
  riskSummary: { critical: number; high: number; medium: number; low: number };
  topPriorities: Vulnerability[];
  recommendations: string[];
}

class VulnerabilityAssessor {
  private vulnerabilities: Map<string, Vulnerability> = new Map();

  addVulnerability(vuln: Vulnerability): void { this.vulnerabilities.set(vuln.id, vuln); }
  getVulnerabilitiesByAsset(assetId: string): Vulnerability[] { return Array.from(this.vulnerabilities.values()).filter(v => v.affectedAsset === assetId); }

  calculateCVSS(breakdown: CVSSBreakdown): number {
    const avValues = { network: 0.85, adjacent: 0.62, local: 0.55, physical: 0.2 };
    const acValues = { low: 0.77, high: 0.44 };
    const prValues = { none: 0.85, low: 0.62, high: 0.27 };
    const uiValues = { none: 0.85, required: 0.62 };
    const impactValues = { none: 0, low: 0.22, high: 0.56 };

    const exploitability = 8.22 * avValues[breakdown.attackVector] * acValues[breakdown.attackComplexity] * prValues[breakdown.privilegesRequired] * uiValues[breakdown.userInteraction];
    const iscBase = 1 - (1 - impactValues[breakdown.confidentialityImpact]) * (1 - impactValues[breakdown.integrityImpact]) * (1 - impactValues[breakdown.availabilityImpact]);
    const impact = breakdown.scope === 'changed' ? 7.52 * (iscBase - 0.029) - 3.25 * Math.pow(iscBase - 0.02, 15) : 6.42 * iscBase;

    if (impact <= 0) return 0;
    const score = breakdown.scope === 'changed' ? Math.min(1.08 * (impact + exploitability), 10) : Math.min(impact + exploitability, 10);
    return Math.ceil(score * 10) / 10;
  }

  classifySeverity(cvssScore: number): 'critical' | 'high' | 'medium' | 'low' | 'none' {
    if (cvssScore >= 9.0) return 'critical';
    if (cvssScore >= 7.0) return 'high';
    if (cvssScore >= 4.0) return 'medium';
    if (cvssScore >= 0.1) return 'low';
    return 'none';
  }

  calculateRiskScore(vuln: Vulnerability): number {
    let score = vuln.cvssScore || 0;
    if (vuln.exploitAvailable) score *= 1.3;
    if (!vuln.patchAvailable) score *= 1.2;
    return Math.min(score, 15);
  }

  prioritizeVulnerabilities(): Vulnerability[] {
    return Array.from(this.vulnerabilities.values()).sort((a, b) => this.calculateRiskScore(b) - this.calculateRiskScore(a));
  }

  createRemediationPlan(vulnerabilityId: string): RemediationPlan {
    const vuln = this.vulnerabilities.get(vulnerabilityId);
    if (!vuln) return { vulnerabilityId, priority: 'low', actions: [], estimatedEffort: 'Unknown', dependencies: [], verificationSteps: [] };

    const severity = this.classifySeverity(vuln.cvssScore || 0);
    let priority: RemediationPlan['priority'] = 'low';
    if (severity === 'critical' || (vuln.exploitAvailable && severity === 'high')) priority = 'immediate';
    else if (severity === 'high') priority = 'high';
    else if (severity === 'medium') priority = 'medium';

    return {
      vulnerabilityId,
      priority,
      actions: vuln.patchAvailable ? ['Apply patch', 'Test in staging'] : ['Implement compensating controls'],
      estimatedEffort: priority === 'immediate' ? '1-4 hours' : '1-2 days',
      dependencies: ['Change approval'],
      verificationSteps: ['Run vulnerability scan', 'Verify fix'],
    };
  }

  groupRemediationEfforts(): { group: string; vulnerabilities: string[]; sharedAction: string }[] {
    const groups: Map<string, string[]> = new Map();
    for (const vuln of this.vulnerabilities.values()) {
      const key = \`asset:\${vuln.affectedAsset}\`;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key)!.push(vuln.id);
    }
    return Array.from(groups.entries()).filter(([_, v]) => v.length > 1).map(([g, v]) => ({ group: g, vulnerabilities: v, sharedAction: 'Coordinate patching' }));
  }

  generateAssessmentReport(assetId: string): AssessmentReport {
    const vulns = this.getVulnerabilitiesByAsset(assetId);
    const summary = { critical: 0, high: 0, medium: 0, low: 0 };
    vulns.forEach(v => { const s = this.classifySeverity(v.cvssScore || 0); if (s !== 'none') summary[s]++; });
    return {
      assetId, scanDate: new Date(), vulnerabilities: vulns, riskSummary: summary,
      topPriorities: this.prioritizeVulnerabilities().filter(v => v.affectedAsset === assetId).slice(0, 5),
      recommendations: ['Address critical vulnerabilities', 'Enable scanning'],
    };
  }

  compareScans(prev: AssessmentReport, curr: AssessmentReport) {
    const prevIds = new Set(prev.vulnerabilities.map(v => v.id));
    const currIds = new Set(curr.vulnerabilities.map(v => v.id));
    return {
      newVulnerabilities: curr.vulnerabilities.filter(v => !prevIds.has(v.id)),
      resolvedVulnerabilities: prev.vulnerabilities.filter(v => !currIds.has(v.id)),
      unchangedVulnerabilities: curr.vulnerabilities.filter(v => prevIds.has(v.id)),
      trendAnalysis: curr.vulnerabilities.length < prev.vulnerabilities.length ? 'Improving' : 'Needs attention',
    };
  }

  explainCVSSVector(vector: string): string {
    const mappings: Record<string, Record<string, string>> = {
      AV: { N: 'Network attack vector', L: 'Local access required' },
      AC: { L: 'Low complexity', H: 'High complexity' },
      C: { H: 'High confidentiality impact', L: 'Low confidentiality impact' },
    };
    return vector.split('/').map(p => { const [k, v] = p.split(':'); return mappings[k]?.[v] || p; }).join('. ');
  }

  suggestInterviewResponse(scenario: string): string {
    if (scenario.includes('critical')) return 'Assess scope, implement mitigations, notify stakeholders, plan permanent fix.';
    return 'Follow structured approach: assess, prioritize, remediate, verify.';
  }
}

describe('VulnerabilityAssessor', () => {
  let assessor: VulnerabilityAssessor;

  beforeEach(() => {
    assessor = new VulnerabilityAssessor();
  });

  it('should add and retrieve vulnerabilities', () => {
    assessor.addVulnerability({
      id: 'v1', cve: 'CVE-2021-44228', title: 'Log4Shell', description: 'RCE',
      affectedAsset: 'server-001', discoveredDate: new Date(), cvssScore: 10.0,
      exploitAvailable: true, patchAvailable: true,
    });

    expect(assessor.getVulnerabilitiesByAsset('server-001')).toHaveLength(1);
    expect(assessor.getVulnerabilitiesByAsset('server-002')).toHaveLength(0);
  });

  it('should calculate CVSS scores', () => {
    const critical = assessor.calculateCVSS({
      attackVector: 'network', attackComplexity: 'low', privilegesRequired: 'none',
      userInteraction: 'none', scope: 'changed', confidentialityImpact: 'high',
      integrityImpact: 'high', availabilityImpact: 'high',
    });

    const low = assessor.calculateCVSS({
      attackVector: 'physical', attackComplexity: 'high', privilegesRequired: 'high',
      userInteraction: 'required', scope: 'unchanged', confidentialityImpact: 'low',
      integrityImpact: 'none', availabilityImpact: 'none',
    });

    expect(critical).toBeGreaterThan(9);
    expect(low).toBeLessThan(3);
  });

  it('should classify severity correctly', () => {
    expect(assessor.classifySeverity(10)).toBe('critical');
    expect(assessor.classifySeverity(8)).toBe('high');
    expect(assessor.classifySeverity(5)).toBe('medium');
    expect(assessor.classifySeverity(2)).toBe('low');
    expect(assessor.classifySeverity(0)).toBe('none');
  });

  it('should prioritize vulnerabilities by risk', () => {
    assessor.addVulnerability({ id: 'v1', title: 'Critical', description: '', affectedAsset: 'a1', discoveredDate: new Date(), cvssScore: 10, exploitAvailable: true, patchAvailable: true });
    assessor.addVulnerability({ id: 'v2', title: 'Low', description: '', affectedAsset: 'a1', discoveredDate: new Date(), cvssScore: 3, exploitAvailable: false, patchAvailable: true });

    const prioritized = assessor.prioritizeVulnerabilities();

    expect(prioritized[0].id).toBe('v1');
  });

  it('should create remediation plans', () => {
    assessor.addVulnerability({ id: 'v1', title: 'Critical', description: '', affectedAsset: 'a1', discoveredDate: new Date(), cvssScore: 10, exploitAvailable: true, patchAvailable: true });

    const plan = assessor.createRemediationPlan('v1');

    expect(plan.priority).toBe('immediate');
    expect(plan.actions.length).toBeGreaterThan(0);
    expect(plan.verificationSteps.length).toBeGreaterThan(0);
  });

  it('should generate assessment reports', () => {
    assessor.addVulnerability({ id: 'v1', title: 'Critical', description: '', affectedAsset: 'server-001', discoveredDate: new Date(), cvssScore: 10, exploitAvailable: true, patchAvailable: true });
    assessor.addVulnerability({ id: 'v2', title: 'Medium', description: '', affectedAsset: 'server-001', discoveredDate: new Date(), cvssScore: 5, exploitAvailable: false, patchAvailable: true });

    const report = assessor.generateAssessmentReport('server-001');

    expect(report.vulnerabilities).toHaveLength(2);
    expect(report.riskSummary.critical).toBe(1);
    expect(report.riskSummary.medium).toBe(1);
    expect(report.recommendations.length).toBeGreaterThan(0);
  });

  it('should explain CVSS vectors', () => {
    const explanation = assessor.explainCVSSVector('AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H');

    expect(explanation).toContain('Network');
    expect(explanation.length).toBeGreaterThan(20);
  });

  it('should suggest interview responses', () => {
    const response = assessor.suggestInterviewResponse('critical vulnerability found');

    expect(response).toContain('Assess');
    expect(response.length).toBeGreaterThan(30);
  });

  it('should compare scans', () => {
    const prev: AssessmentReport = {
      assetId: 'a1', scanDate: new Date(), vulnerabilities: [{ id: 'v1', title: 'Old', description: '', affectedAsset: 'a1', discoveredDate: new Date(), exploitAvailable: false, patchAvailable: true }],
      riskSummary: { critical: 0, high: 0, medium: 1, low: 0 }, topPriorities: [], recommendations: [],
    };
    const curr: AssessmentReport = {
      assetId: 'a1', scanDate: new Date(), vulnerabilities: [{ id: 'v2', title: 'New', description: '', affectedAsset: 'a1', discoveredDate: new Date(), exploitAvailable: false, patchAvailable: true }],
      riskSummary: { critical: 0, high: 0, medium: 1, low: 0 }, topPriorities: [], recommendations: [],
    };

    const comparison = assessor.compareScans(prev, curr);

    expect(comparison.newVulnerabilities).toHaveLength(1);
    expect(comparison.resolvedVulnerabilities).toHaveLength(1);
  });
});`,
	hint1:
		'For CVSS calculation, use the base score formula: Impact + Exploitability, capped at 10. Exploitability = 8.22 × AV × AC × PR × UI. Remember to handle scope changes differently.',
	hint2:
		'For risk prioritization, consider multiple factors: CVSS score is the base, but increase risk if exploit is available (more likely to be attacked) and if no patch is available (harder to fix).',
	whyItMatters: `Vulnerability assessment is a core skill tested in security interviews:

**Why This Matters:**
- **Practical Skill** - Every security team runs vulnerability assessments
- **Risk Communication** - Translating technical findings to business impact
- **Prioritization** - Resources are limited; you must focus on what matters

**Interview Expectations:**
- Understand CVSS scoring and what the numbers mean
- Explain how to prioritize vulnerabilities beyond just CVSS
- Create actionable remediation plans
- Communicate findings to technical and non-technical audiences

**Common Interview Questions:**
- "We found 500 vulnerabilities. How do you prioritize?"
- "Explain this CVSS vector to me"
- "There's no patch available. What do you do?"
- "The business says they can't patch for 3 months. How do you respond?"

**Real-World Context:**
- **Equifax Breach**: Known vulnerability (CVE-2017-5638) was not patched
- **Heartbleed**: CVSS 7.5 but massive impact due to widespread use
- **Log4Shell**: CVSS 10.0 - demonstrated need for rapid response

Understanding vulnerability assessment shows you can handle real security operations.`,
	order: 4,
	translations: {
		ru: {
			title: 'Демонстрация оценки уязвимостей',
			description: `Практикуйте навыки оценки уязвимостей для технических собеседований по безопасности.

**Области оценки:**

1. **Сканирование уязвимостей** - Инструменты и техники
2. **Оценка CVSS** - Понимание рейтингов серьёзности
3. **Приоритизация рисков** - Какие уязвимости важнее
4. **Планирование устранения** - Как исправлять уязвимости
5. **Отчётность** - Эффективная коммуникация результатов

**Ваша задача:**

Реализуйте класс \`VulnerabilityAssessor\`, демонстрирующий методологию оценки уязвимостей.`,
			hint1:
				'Для расчёта CVSS используйте формулу базового балла: Воздействие + Эксплуатируемость, ограничено 10. Эксплуатируемость = 8.22 × AV × AC × PR × UI.',
			hint2:
				'Для приоритизации рисков учитывайте несколько факторов: CVSS - база, но увеличивайте риск если эксплоит доступен и если патч недоступен.',
			whyItMatters: `Оценка уязвимостей - ключевой навык на собеседованиях по безопасности:

**Почему это важно:**
- **Практический навык** - Каждая команда безопасности проводит оценку уязвимостей
- **Коммуникация рисков** - Перевод технических находок в бизнес-влияние
- **Приоритизация** - Ресурсы ограничены; нужно фокусироваться на важном

**Ожидания на собеседовании:**
- Понимать оценку CVSS и значение чисел
- Объяснить как приоритизировать уязвимости помимо CVSS
- Создавать действенные планы устранения
- Общаться с техническими и нетехническими аудиториями`,
		},
		uz: {
			title: 'Zaifliklarni baholash namoyishi',
			description: `Texnik xavfsizlik intervyulari uchun zaifliklarni baholash ko'nikmalarini mashq qiling.

**Baholash sohalari:**

1. **Zaiflik skanerlash** - Vositalar va texnikalar
2. **CVSS baholash** - Jiddiylik reytinglarini tushunish
3. **Xavfni ustuvorlash** - Qaysi zaifliklar muhimroq
4. **Tuzatishni rejalashtirish** - Zaifliklarni qanday tuzatish
5. **Hisobot** - Natijalarni samarali yetkazish

**Vazifangiz:**

Zaifliklarni baholash metodologiyasini namoyish etadigan \`VulnerabilityAssessor\` klassini yarating.`,
			hint1:
				"CVSS hisoblash uchun asosiy ball formulasidan foydalaning: Ta'sir + Ekspluatatsiya qobiliyati, 10 bilan cheklangan. Ekspluatatsiya = 8.22 × AV × AC × PR × UI.",
			hint2:
				"Xavfni ustuvorlashda bir nechta omillarni hisobga oling: CVSS - asos, lekin exploit mavjud bo'lsa va patch mavjud bo'lmasa xavfni oshiring.",
			whyItMatters: `Zaifliklarni baholash xavfsizlik intervyularida tekshiriladigan asosiy ko'nikma:

**Nima uchun muhim:**
- **Amaliy ko'nikma** - Har bir xavfsizlik jamoasi zaifliklarni baholaydi
- **Xavf kommunikatsiyasi** - Texnik topilmalarni biznes ta'siriga tarjima qilish
- **Ustuvorlash** - Resurslar cheklangan; muhimga e'tibor qaratish kerak

**Intervyu kutishlari:**
- CVSS baholash va raqamlar ma'nosini tushunish
- Zaifliklarni CVSS dan tashqari qanday ustuvorlashtirish
- Amaliy tuzatish rejalarini yaratish
- Texnik va texnik bo'lmagan auditoriyalar bilan muloqot qilish`,
		},
	},
};

export default task;
