import { Task } from '../../../../types';

export const task: Task = {
	slug: 'go-testing-mock-database',
	title: 'Mock Database Layer',
	difficulty: 'hard',	tags: ['go', 'testing', 'database', 'mocking'],
	estimatedTime: '30m',	isPremium: false,
	youtubeUrl: '',
	description: `Mock database operations using repository pattern for isolated business logic testing.

**Requirements:**
1. Define \`Repository\` interface: Create, GetByID, Update
2. Implement \`OrderService\` using repository
3. Create \`MockRepository\` for testing
4. Test order creation without real database
5. Verify repository method calls

**Constraints:**
- Repository interface must support CRUD operations
- Mock should be reusable
- Test service logic in isolation`,
	initialCode: `package dbmock_test

import "testing"

type Order struct {
	ID     int
	UserID int
	Total  float64
}

// TODO: Define Repository interface
type Repository interface {
	Create(order Order) error
	GetByID(id int) (Order, error)
}

// TODO: Implement OrderService
type OrderService struct {
	repo Repository
}

func NewOrderService(repo Repository) *OrderService {
	return &OrderService{repo: repo}
}

// TODO: Implement PlaceOrder method
func (s *OrderService) PlaceOrder(userID int, total float64) (int, error) {
	// TODO: Implement
}

// TODO: Create MockRepository
type MockRepository struct{}

// TODO: Write tests
func TestOrderService_PlaceOrder(t *testing.T) {
	// TODO: Implement
}`,
	solutionCode: `package dbmock_test

import (
	"errors"
	"testing"
)

type Order struct {
	ID     int
	UserID int
	Total  float64
}

type Repository interface {
	Create(order Order) error
	GetByID(id int) (Order, error)
}

type OrderService struct {
	repo Repository
}

func NewOrderService(repo Repository) *OrderService {
	return &OrderService{repo: repo}
}

func (s *OrderService) PlaceOrder(userID int, total float64) (int, error) {
	if total <= 0 {	// Validate input
		return 0, errors.New("invalid total")
	}

	order := Order{
		ID:     1,	// Would be generated by DB
		UserID: userID,
		Total:  total,
	}

	err := s.repo.Create(order)	// Call repository
	if err != nil {
		return 0, err
	}

	return order.ID, nil
}

type MockRepository struct {
	CreateFunc  func(order Order) error
	GetByIDFunc func(id int) (Order, error)
	Calls       []string	// Track method calls
}

func (m *MockRepository) Create(order Order) error {
	m.Calls = append(m.Calls, "Create")	// Record call
	if m.CreateFunc != nil {
		return m.CreateFunc(order)
	}
	return nil
}

func (m *MockRepository) GetByID(id int) (Order, error) {
	m.Calls = append(m.Calls, "GetByID")
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(id)
	}
	return Order{}, nil
}

func TestOrderService_PlaceOrder(t *testing.T) {
	t.Run("success", func(t *testing.T) {
		mock := &MockRepository{
			CreateFunc: func(order Order) error {
				// Verify order data
				if order.UserID != 123 {
					t.Errorf("UserID = %d, want 123", order.UserID)
				}
				if order.Total != 99.99 {
					t.Errorf("Total = %f, want 99.99", order.Total)
				}
				return nil
			},
		}

		service := NewOrderService(mock)
		orderID, err := service.PlaceOrder(123, 99.99)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if orderID == 0 {
			t.Error("expected non-zero order ID")
		}
		if len(mock.Calls) != 1 || mock.Calls[0] != "Create" {
			t.Errorf("calls = %v, want [Create]", mock.Calls)
		}
	})

	t.Run("invalid total", func(t *testing.T) {
		mock := &MockRepository{}
		service := NewOrderService(mock)

		_, err := service.PlaceOrder(123, -10)

		if err == nil {
			t.Fatal("expected error for negative total")
		}
		if len(mock.Calls) != 0 {
			t.Error("Create should not be called for invalid input")
		}
	})

	t.Run("database error", func(t *testing.T) {
		mock := &MockRepository{
			CreateFunc: func(order Order) error {
				return errors.New("db error")
			},
		}

		service := NewOrderService(mock)
		_, err := service.PlaceOrder(123, 99.99)

		if err == nil {
			t.Fatal("expected error from repository")
		}
	})
}`,
			hint1: `Repository pattern abstracts database operations behind an interface, making business logic testable.`,
			hint2: `Track method calls in mock to verify service behavior.`,
			testCode: `package dbmock_test

import (
	"errors"
	"testing"
)

func Test1(t *testing.T) {
	mock := &MockRepository{
		CreateFunc: func(order Order) error { return nil },
	}
	service := NewOrderService(mock)
	orderID, err := service.PlaceOrder(1, 100.0)
	if err != nil || orderID == 0 {
		t.Errorf("expected success, got orderID=%d, err=%v", orderID, err)
	}
}

func Test2(t *testing.T) {
	mock := &MockRepository{}
	service := NewOrderService(mock)
	_, err := service.PlaceOrder(1, -50.0)
	if err == nil {
		t.Error("expected error for negative total")
	}
}

func Test3(t *testing.T) {
	mock := &MockRepository{}
	service := NewOrderService(mock)
	_, err := service.PlaceOrder(1, 0)
	if err == nil {
		t.Error("expected error for zero total")
	}
}

func Test4(t *testing.T) {
	mock := &MockRepository{
		CreateFunc: func(order Order) error {
			return errors.New("connection refused")
		},
	}
	service := NewOrderService(mock)
	_, err := service.PlaceOrder(1, 100.0)
	if err == nil {
		t.Error("expected database error")
	}
}

func Test5(t *testing.T) {
	var capturedOrder Order
	mock := &MockRepository{
		CreateFunc: func(order Order) error {
			capturedOrder = order
			return nil
		},
	}
	service := NewOrderService(mock)
	service.PlaceOrder(42, 99.99)
	if capturedOrder.UserID != 42 || capturedOrder.Total != 99.99 {
		t.Errorf("order not captured correctly: %+v", capturedOrder)
	}
}

func Test6(t *testing.T) {
	mock := &MockRepository{
		CreateFunc: func(order Order) error { return nil },
	}
	service := NewOrderService(mock)
	service.PlaceOrder(1, 50.0)
	if len(mock.Calls) != 1 || mock.Calls[0] != "Create" {
		t.Errorf("expected [Create], got %v", mock.Calls)
	}
}

func Test7(t *testing.T) {
	mock := &MockRepository{}
	service := NewOrderService(mock)
	service.PlaceOrder(1, -10)
	if len(mock.Calls) != 0 {
		t.Error("Create should not be called for invalid input")
	}
}

func Test8(t *testing.T) {
	mock := &MockRepository{
		CreateFunc: func(order Order) error { return nil },
	}
	service := NewOrderService(mock)
	id1, _ := service.PlaceOrder(1, 10.0)
	id2, _ := service.PlaceOrder(2, 20.0)
	if id1 == 0 || id2 == 0 {
		t.Error("expected non-zero order IDs")
	}
}

func Test9(t *testing.T) {
	mock := &MockRepository{
		CreateFunc: func(order Order) error { return nil },
	}
	service := NewOrderService(mock)
	_, err := service.PlaceOrder(0, 100.0)
	if err != nil {
		t.Error("userID=0 should be valid")
	}
}

func Test10(t *testing.T) {
	mock := &MockRepository{
		CreateFunc: func(order Order) error { return nil },
	}
	service := NewOrderService(mock)
	_, err := service.PlaceOrder(1, 0.01)
	if err != nil {
		t.Error("small positive total should be valid")
	}
}
`,
			whyItMatters: `Database mocking enables fast, isolated testing of business logic without database setup.`,
			order: 2,
	translations: {
		ru: {
			title: 'Создание мока базы данных',
			description: `Мокируйте операции с базой данных используя repository паттерн для изолированного тестирования бизнес-логики.`,
			hint1: `Repository паттерн абстрагирует операции БД за интерфейсом.`,
			hint2: `Отслеживайте вызовы методов в mock для проверки поведения.`,
			whyItMatters: `Мокирование БД позволяет быстро тестировать бизнес-логику без настройки БД.`,
			solutionCode: `package dbmock_test

import (
	"errors"
	"testing"
)

type Order struct {
	ID     int
	UserID int
	Total  float64
}

type Repository interface {
	Create(order Order) error
	GetByID(id int) (Order, error)
}

type OrderService struct {
	repo Repository
}

func NewOrderService(repo Repository) *OrderService {
	return &OrderService{repo: repo}
}

func (s *OrderService) PlaceOrder(userID int, total float64) (int, error) {
	if total <= 0 {	// Валидировать ввод
		return 0, errors.New("invalid total")
	}

	order := Order{
		ID:     1,
		UserID: userID,
		Total:  total,
	}

	err := s.repo.Create(order)	// Вызвать repository
	if err != nil {
		return 0, err
	}

	return order.ID, nil
}

type MockRepository struct {
	CreateFunc  func(order Order) error
	GetByIDFunc func(id int) (Order, error)
	Calls       []string	// Отслеживать вызовы методов
}

func (m *MockRepository) Create(order Order) error {
	m.Calls = append(m.Calls, "Create")	// Записать вызов
	if m.CreateFunc != nil {
		return m.CreateFunc(order)
	}
	return nil
}

func (m *MockRepository) GetByID(id int) (Order, error) {
	m.Calls = append(m.Calls, "GetByID")
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(id)
	}
	return Order{}, nil
}

func TestOrderService_PlaceOrder(t *testing.T) {
	t.Run("успех", func(t *testing.T) {
		mock := &MockRepository{
			CreateFunc: func(order Order) error {
				// Проверить данные заказа
				if order.UserID != 123 {
					t.Errorf("UserID = %d, want 123", order.UserID)
				}
				if order.Total != 99.99 {
					t.Errorf("Total = %f, want 99.99", order.Total)
				}
				return nil
			},
		}

		service := NewOrderService(mock)
		orderID, err := service.PlaceOrder(123, 99.99)

		if err != nil {
			t.Fatalf("неожиданная ошибка: %v", err)
		}
		if orderID == 0 {
			t.Error("ожидается ненулевой ID заказа")
		}
		if len(mock.Calls) != 1 || mock.Calls[0] != "Create" {
			t.Errorf("calls = %v, want [Create]", mock.Calls)
		}
	})

	t.Run("невалидный total", func(t *testing.T) {
		mock := &MockRepository{}
		service := NewOrderService(mock)

		_, err := service.PlaceOrder(123, -10)

		if err == nil {
			t.Fatal("ожидается ошибка для отрицательного total")
		}
		if len(mock.Calls) != 0 {
			t.Error("Create не должен вызываться для невалидного ввода")
		}
	})

	t.Run("ошибка базы данных", func(t *testing.T) {
		mock := &MockRepository{
			CreateFunc: func(order Order) error {
				return errors.New("db error")
			},
		}

		service := NewOrderService(mock)
		_, err := service.PlaceOrder(123, 99.99)

		if err == nil {
			t.Fatal("ожидается ошибка от repository")
		}
	})
}`
		},
		uz: {
			title: `Database mockini yaratish`,
			description: `Biznes mantiqni izolyatsiya qilingan testlash uchun repository patternidan foydalanib ma'lumotlar bazasi operatsiyalarini mock qiling.`,
			hint1: `Repository pattern DB operatsiyalarini interfeys orqali abstraktlaydi.`,
			hint2: `Xatti-harakatni tekshirish uchun mock da metod chaqiruvlarini kuzating.`,
			whyItMatters: `DB mocking ma'lumotlar bazasini sozlamasdan biznes mantiqni tez testlashga imkon beradi.`,
			solutionCode: `package dbmock_test

import (
	"errors"
	"testing"
)

type Order struct {
	ID     int
	UserID int
	Total  float64
}

type Repository interface {
	Create(order Order) error
	GetByID(id int) (Order, error)
}

type OrderService struct {
	repo Repository
}

func NewOrderService(repo Repository) *OrderService {
	return &OrderService{repo: repo}
}

func (s *OrderService) PlaceOrder(userID int, total float64) (int, error) {
	if total <= 0 {	// Kirishni tekshirish
		return 0, errors.New("invalid total")
	}

	order := Order{
		ID:     1,
		UserID: userID,
		Total:  total,
	}

	err := s.repo.Create(order)	// Repository ni chaqirish
	if err != nil {
		return 0, err
	}

	return order.ID, nil
}

type MockRepository struct {
	CreateFunc  func(order Order) error
	GetByIDFunc func(id int) (Order, error)
	Calls       []string	// Metod chaqiruvlarini kuzatish
}

func (m *MockRepository) Create(order Order) error {
	m.Calls = append(m.Calls, "Create")	// Chaqiruvni yozib olish
	if m.CreateFunc != nil {
		return m.CreateFunc(order)
	}
	return nil
}

func (m *MockRepository) GetByID(id int) (Order, error) {
	m.Calls = append(m.Calls, "GetByID")
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(id)
	}
	return Order{}, nil
}

func TestOrderService_PlaceOrder(t *testing.T) {
	t.Run("muvaffaqiyat", func(t *testing.T) {
		mock := &MockRepository{
			CreateFunc: func(order Order) error {
				// Buyurtma ma'lumotlarini tekshirish
				if order.UserID != 123 {
					t.Errorf("UserID = %d, want 123", order.UserID)
				}
				if order.Total != 99.99 {
					t.Errorf("Total = %f, want 99.99", order.Total)
				}
				return nil
			},
		}

		service := NewOrderService(mock)
		orderID, err := service.PlaceOrder(123, 99.99)

		if err != nil {
			t.Fatalf("kutilmagan xato: %v", err)
		}
		if orderID == 0 {
			t.Error("noldan farqli buyurtma ID si kutilgan")
		}
		if len(mock.Calls) != 1 || mock.Calls[0] != "Create" {
			t.Errorf("calls = %v, want [Create]", mock.Calls)
		}
	})

	t.Run("noto'g'ri total", func(t *testing.T) {
		mock := &MockRepository{}
		service := NewOrderService(mock)

		_, err := service.PlaceOrder(123, -10)

		if err == nil {
			t.Fatal("manfiy total uchun xato kutilgan")
		}
		if len(mock.Calls) != 0 {
			t.Error("Noto'g'ri kirish uchun Create chaqirilmasligi kerak")
		}
	})

	t.Run("ma'lumotlar bazasi xatosi", func(t *testing.T) {
		mock := &MockRepository{
			CreateFunc: func(order Order) error {
				return errors.New("db error")
			},
		}

		service := NewOrderService(mock)
		_, err := service.PlaceOrder(123, 99.99)

		if err == nil {
			t.Fatal("repository dan xato kutilgan")
		}
	})
}`
		}
	}
};

export default task;
